name: Release

on:
  release:
    types: [published]

jobs:
  publish:
    runs-on: ubuntu-latest
    environment: release
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.10"
    
    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine wheel

        # Install runtime dependencies needed for pre-build validation
        pip install PyYAML>=5.1 requests>=2.25.0 aiohttp>=3.8.0 typing-extensions>=4.0.0
    
    - name: Fix package structure
      run: |
        # Package structure is now correct - core and utils are already in ai_threat_monitor package
        echo "‚úÖ Package structure verified for production - all modules are in ai_threat_monitor package"
        
        if [ -d "src/config" ] && [ ! -d "src/ai_threat_monitor/config" ]; then
          mv src/config src/ai_threat_monitor/config
          echo "Moved config into ai_threat_monitor package"
        elif [ -d "src/config" ] && [ -d "src/ai_threat_monitor/config" ]; then
          echo "Merging src/config into existing src/ai_threat_monitor/config"
          cp -r src/config/* src/ai_threat_monitor/config/
          rm -rf src/config
        fi
        
        if [ -d "src/engines" ] && [ ! -d "src/ai_threat_monitor/engines" ]; then
          mv src/engines src/ai_threat_monitor/engines
          echo "Moved engines into ai_threat_monitor package"
        elif [ -d "src/engines" ] && [ -d "src/ai_threat_monitor/engines" ]; then
          echo "Merging src/engines into existing src/ai_threat_monitor/engines"
          cp -r src/engines/* src/ai_threat_monitor/engines/
          rm -rf src/engines
        fi
        
        if [ -d "src/integrations" ] && [ ! -d "src/ai_threat_monitor/integrations" ]; then
          mv src/integrations src/ai_threat_monitor/integrations
          echo "Moved integrations into ai_threat_monitor package"
        elif [ -d "src/integrations" ] && [ -d "src/ai_threat_monitor/integrations" ]; then
          echo "Merging src/integrations into existing src/ai_threat_monitor/integrations"
          cp -r src/integrations/* src/ai_threat_monitor/integrations/
          rm -rf src/integrations
        fi
        
        # Import normalization - much simpler approach
        echo "üîß Normalizing import statements..."

        # The current imports are mostly correct. We only need minimal fixes:
        # 1. Ensure root-level files use relative imports consistently
        # 2. Keep absolute imports for nested files (they work correctly)

        echo "‚úÖ Current imports are already mostly correct - minimal fixes needed"
        echo "‚úÖ Absolute imports like 'from ai_threat_monitor.models.analysis_result import' work correctly"
        echo "‚úÖ Root-level relative imports like 'from .models.analysis_result import' work correctly"
        
        # Additional comprehensive import fixes for all moved files
        echo "üîß Comprehensive import fixes for all moved modules..."

        # IMPORTANT: Keep absolute imports for models, utils, and core - they work correctly
        # The absolute import pattern 'from ai_threat_monitor.models.analysis_result import' is correct
        # Do NOT convert these to relative imports as it breaks the package structure
        echo "‚úÖ Keeping absolute imports for ai_threat_monitor.models.*, ai_threat_monitor.utils.*, ai_threat_monitor.core.*"

        # Only fix root-level files that need relative imports
        sed -i 's|from \.\.models\.|from .models.|g' src/ai_threat_monitor/__init__.py
        sed -i 's|from \.\.utils\.|from .utils.|g' src/ai_threat_monitor/__init__.py
        sed -i 's|from \.\.core\.|from .core.|g' src/ai_threat_monitor/__init__.py
        
        echo "‚úÖ All import paths fixed"
        
        # Ensure all directories have __init__.py files
        echo "üîç Ensuring all Python packages have __init__.py files..."
        for dir in src/ai_threat_monitor/*/; do
          if [ -d "$dir" ] && [ ! -f "$dir/__init__.py" ]; then
            echo "Creating missing __init__.py in $dir"
            echo '"""Package module"""' > "$dir/__init__.py"
          fi
        done
        
        # Also check nested directories
        find src/ai_threat_monitor -type d -mindepth 2 | while read dir; do
          if [ ! -f "$dir/__init__.py" ]; then
            echo "Creating missing __init__.py in $dir"
            echo '"""Package module"""' > "$dir/__init__.py"
          fi
        done
        
        echo "‚úÖ Package structure fixed for production release"
    
    - name: Security scan before production release
      run: |
        echo "üîç Production security scan..."
        
        # Check for common secret patterns (excluding test files and documentation)
        if grep -r -i --exclude-dir=.git --exclude-dir=tests --exclude="*.md" \
           -E "(password|secret|private.*key)\s*[:=]\s*['\"][^'\"]{10,}" src/; then
          echo "‚ùå Potential secrets found in source code!"
          exit 1
        fi
        
        # Ensure we're using production API endpoints (not dev)
        if grep -r "dev-api\.securevector\.io\|api-test\.securevector\.io" src/; then
          echo "‚ùå Development/test API URLs found in production release!"
          echo "Production releases should use api.securevector.io"
          exit 1
        fi
        
        echo "‚úÖ Production security scan passed"

    - name: Pre-build validation
      run: |
        echo "üîç Running pre-build import validation..."

        # Test that all critical imports work correctly
        echo "Testing critical imports..."
        PYTHONPATH=src python3 -c "
        import sys
        try:
            from ai_threat_monitor import SecureVectorClient, AsyncSecureVectorClient
            print('‚úÖ Main client imports successful')

            from ai_threat_monitor.core.modes import APIMode, LocalMode, HybridMode
            print('‚úÖ Mode imports successful')

            from ai_threat_monitor.models import AnalysisResult, ThreatDetection
            print('‚úÖ Model imports successful')

            from ai_threat_monitor.testing import MockSecureVectorClient, create_test_prompts
            print('‚úÖ Testing imports successful')

            print('‚úÖ All critical imports successful')
        except ImportError as e:
            print(f'‚ùå Import error: {e}')
            # Check if it's a missing dependency vs broken import structure
            if 'yaml' in str(e):
                print('üí° This appears to be a missing dependency issue, not an import structure problem')
                print('üí° Dependencies will be installed automatically when the package is installed')
            else:
                print('‚ùå This appears to be an import structure problem')
                import traceback
                traceback.print_exc()
                sys.exit(1)
        except Exception as e:
            print(f'‚ùå Unexpected error: {e}')
            import traceback
            traceback.print_exc()
            sys.exit(1)
        "

        # Check for problematic relative imports that would break the package
        echo "Checking for problematic import patterns..."
        if grep -E "from \.\.(utils|models|core)" src/ai_threat_monitor/core/modes/api/api_mode.py 2>/dev/null; then
            echo "‚ùå Found problematic relative imports in api_mode.py"
            echo "These will cause 'ModuleNotFoundError: No module named ai_threat_monitor.core.modes.models'"
            exit 1
        fi

        echo "‚úÖ Pre-build validation passed"

    - name: Build package
      run: python -m build
    
    - name: Check package
      run: twine check dist/*
    
    - name: Publish to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        user: __token__
        password: ${{ secrets.PYPI_API_TOKEN }}
        skip-existing: true
    
    - name: Upload to GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        files: dist/*
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

