name: Develop Branch Preview Publish

on:
  push:
    branches: [ develop ]
  workflow_dispatch:

jobs:
  test-publish:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.10"
    
    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine wheel
    
    - name: Generate development version
      run: |
        # Create a unique dev version with timestamp (no local identifier)
        # Format: 1.0.0.devYYYYMMDDHHMMSS (PEP 440 compliant)
        TIMESTAMP=$(date +%Y%m%d%H%M%S)
        DEV_VERSION="1.0.0.dev${TIMESTAMP}"
        echo "DEV_VERSION=$DEV_VERSION" >> $GITHUB_ENV
        
        # Update version in __init__.py
        sed -i "s/__version__ = \".*\"/__version__ = \"$DEV_VERSION\"/" src/ai_threat_monitor/__init__.py
        
        # Use a test-specific package name to avoid conflicts
        sed -i "s/name=\"securevector-ai-monitor\"/name=\"securevector-ai-monitor-dev\"/" setup.py
        
        # Add development warning to package description
        sed -i 's/description="Real-time AI threat monitoring\./description="[DEVELOPMENT BUILD] Real-time AI threat monitoring./' setup.py
        
        # Package structure is now correct - core and utils are already in ai_threat_monitor package
        echo "‚úÖ Package structure verified - all modules are in ai_threat_monitor package"
        
        if [ -d "src/config" ] && [ ! -d "src/ai_threat_monitor/config" ]; then
          mv src/config src/ai_threat_monitor/config
          echo "Moved config into ai_threat_monitor package"
        elif [ -d "src/config" ] && [ -d "src/ai_threat_monitor/config" ]; then
          echo "Merging src/config into existing src/ai_threat_monitor/config"
          cp -r src/config/* src/ai_threat_monitor/config/
          rm -rf src/config
        fi
        
        if [ -d "src/engines" ] && [ ! -d "src/ai_threat_monitor/engines" ]; then
          mv src/engines src/ai_threat_monitor/engines
          echo "Moved engines into ai_threat_monitor package"
        elif [ -d "src/engines" ] && [ -d "src/ai_threat_monitor/engines" ]; then
          echo "Merging src/engines into existing src/ai_threat_monitor/engines"
          cp -r src/engines/* src/ai_threat_monitor/engines/
          rm -rf src/engines
        fi
        
        if [ -d "src/integrations" ] && [ ! -d "src/ai_threat_monitor/integrations" ]; then
          mv src/integrations src/ai_threat_monitor/integrations
          echo "Moved integrations into ai_threat_monitor package"
        elif [ -d "src/integrations" ] && [ -d "src/ai_threat_monitor/integrations" ]; then
          echo "Merging src/integrations into existing src/ai_threat_monitor/integrations"
          cp -r src/integrations/* src/ai_threat_monitor/integrations/
          rm -rf src/integrations
        fi
        
        # Update all API URLs to use development endpoint (prevent accidental production calls)
        sed -i 's|api_url: str = "https://api.securevector.io"|api_url: str = "https://dev-api.securevector.io"|' src/ai_threat_monitor/models/config_models.py
        sed -i 's|api.securevector.io|dev-api.securevector.io|g' src/ai_threat_monitor/core/modes/api/api_analyzer.py
        sed -i 's|api.securevector.io|dev-api.securevector.io|g' src/ai_threat_monitor/__init__.py
        
        echo "Using development version: $DEV_VERSION"
        echo "Using test package name: securevector-ai-monitor-dev"
        echo "Git commit: $(git rev-parse --short HEAD)"
        # Fix import statements to use proper package paths
        echo "üîß Fixing import statements..."
        
        # First, fix root-level files (client.py, async_client.py, etc.) to use single-dot imports
        echo "üîß Fixing root-level file imports..."
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from utils\.|from .utils.|g' {} \;
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from core\.|from .core.|g' {} \;
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from config\.|from .config.|g' {} \;
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from engines\.|from .engines.|g' {} \;
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from integrations\.|from .integrations.|g' {} \;
        
        # Fix root-level imports without dots (direct module imports)
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from utils import|from .utils import|g' {} \;
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from core import|from .core import|g' {} \;
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from config import|from .config import|g' {} \;
        
        # Then fix nested files to use double-dot imports (but skip root level)
        echo "üîß Fixing nested file imports..."
        find src/ai_threat_monitor -mindepth 2 -name "*.py" -type f -exec sed -i 's|from utils\.|from ai_threat_monitor.utils.|g' {} \;
        find src/ai_threat_monitor -mindepth 2 -name "*.py" -type f -exec sed -i 's|from core\.|from ai_threat_monitor.core.|g' {} \;
        find src/ai_threat_monitor -mindepth 2 -name "*.py" -type f -exec sed -i 's|from config\.|from ai_threat_monitor.config.|g' {} \;
        find src/ai_threat_monitor -mindepth 2 -name "*.py" -type f -exec sed -i 's|from engines\.|from ai_threat_monitor.engines.|g' {} \;
        find src/ai_threat_monitor -mindepth 2 -name "*.py" -type f -exec sed -i 's|from integrations\.|from ai_threat_monitor.integrations.|g' {} \;
        
        # Fix nested imports without dots (direct module imports)
        find src/ai_threat_monitor -mindepth 2 -name "*.py" -type f -exec sed -i 's|from utils import|from ai_threat_monitor.utils import|g' {} \;
        find src/ai_threat_monitor -mindepth 2 -name "*.py" -type f -exec sed -i 's|from core import|from ai_threat_monitor.core import|g' {} \;
        find src/ai_threat_monitor -mindepth 2 -name "*.py" -type f -exec sed -i 's|from config import|from ai_threat_monitor.config import|g' {} \;
        
        # Fix specific problematic imports - but handle root vs nested differently
        # Root level files need single-dot imports
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from utils\.exceptions|from .utils.exceptions|g' {} \;
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from utils\.logger|from .utils.logger|g' {} \;
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from utils\.security|from .utils.security|g' {} \;
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from utils\.auto_config|from .utils.auto_config|g' {} \;
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from core\.modes|from .core.modes|g' {} \;
        
        # Nested files need absolute imports (will be converted to relative later)
        find src/ai_threat_monitor -mindepth 2 -name "*.py" -type f -exec sed -i 's|from utils\.exceptions|from ai_threat_monitor.utils.exceptions|g' {} \;
        find src/ai_threat_monitor -mindepth 2 -name "*.py" -type f -exec sed -i 's|from utils\.logger|from ai_threat_monitor.utils.logger|g' {} \;
        find src/ai_threat_monitor -mindepth 2 -name "*.py" -type f -exec sed -i 's|from utils\.security|from ai_threat_monitor.utils.security|g' {} \;
        find src/ai_threat_monitor -mindepth 2 -name "*.py" -type f -exec sed -i 's|from utils\.auto_config|from ai_threat_monitor.utils.auto_config|g' {} \;
        
        # Fix __init__.py imports specifically (need relative imports for package root)
        sed -i 's|from utils\.auto_config import|from .utils.auto_config import|g' src/ai_threat_monitor/__init__.py
        
        # Fix auto_config.py imports (now that it's inside ai_threat_monitor, use relative imports)
        if [ -f "src/ai_threat_monitor/utils/auto_config.py" ]; then
          echo "üîß Fixing auto_config.py imports..."
          echo "Before fix:"
          grep "from ai_threat_monitor.models.config_models" src/ai_threat_monitor/utils/auto_config.py || echo "Pattern not found"
          
          sed -i 's|from ai_threat_monitor\.models\.config_models|from ..models.config_models|g' src/ai_threat_monitor/utils/auto_config.py
          
          echo "After fix:"
          grep "from.*models.config_models" src/ai_threat_monitor/utils/auto_config.py || echo "No models.config_models import found"
          echo "Fixed auto_config.py imports to use relative paths"
        else
          echo "‚ùå auto_config.py not found at expected location"
          ls -la src/ai_threat_monitor/utils/ || echo "utils directory not found"
        fi
        
        # Additional comprehensive import fixes for all moved files
        echo "üîß Comprehensive import fixes for all moved modules..."

        # IMPORTANT: Keep absolute imports for models, utils, and core - they work correctly
        # The absolute import pattern 'from ai_threat_monitor.models.analysis_result import' is correct
        # Do NOT convert these to relative imports as it breaks the package structure
        echo "‚úÖ Keeping absolute imports for ai_threat_monitor.models.*, ai_threat_monitor.utils.*, ai_threat_monitor.core.*"
        
        # Fix files at package root level (need single dot, not double dot)
        sed -i 's|from \.\.models\.|from .models.|g' src/ai_threat_monitor/__init__.py
        sed -i 's|from \.\.utils\.|from .utils.|g' src/ai_threat_monitor/__init__.py
        sed -i 's|from \.\.core\.|from .core.|g' src/ai_threat_monitor/__init__.py
        
        sed -i 's|from \.\.models\.|from .models.|g' src/ai_threat_monitor/client.py
        sed -i 's|from \.\.utils\.|from .utils.|g' src/ai_threat_monitor/client.py
        sed -i 's|from \.\.core\.|from .core.|g' src/ai_threat_monitor/client.py
        
        sed -i 's|from \.\.models\.|from .models.|g' src/ai_threat_monitor/async_client.py
        sed -i 's|from \.\.utils\.|from .utils.|g' src/ai_threat_monitor/async_client.py
        sed -i 's|from \.\.core\.|from .core.|g' src/ai_threat_monitor/async_client.py
        
        # Fix any other root-level files
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from \.\.models\.|from .models.|g' {} \;
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from \.\.utils\.|from .utils.|g' {} \;
        find src/ai_threat_monitor -maxdepth 1 -name "*.py" -type f -exec sed -i 's|from \.\.core\.|from .core.|g' {} \;
        
        echo "‚úÖ All import paths fixed"
        
        # Debug: Show final package structure
        echo "üì¶ Final package structure:"
        find src/ai_threat_monitor -type f -name "*.py" | head -20
        echo ""
        echo "üìÅ Directory structure:"
        ls -la src/ai_threat_monitor/
        echo ""
        echo "üìÅ Models directory:"
        ls -la src/ai_threat_monitor/models/ || echo "‚ùå models directory not found"
        echo ""
        echo "üìÅ Utils directory:"  
        ls -la src/ai_threat_monitor/utils/ || echo "‚ùå utils directory not found"
        echo ""
        echo "üîç Checking for missing __init__.py files:"
        
        # Ensure all directories have __init__.py files
        for dir in src/ai_threat_monitor/*/; do
          if [ -d "$dir" ] && [ ! -f "$dir/__init__.py" ]; then
            echo "Creating missing __init__.py in $dir"
            echo '"""Package module"""' > "$dir/__init__.py"
          fi
        done
        
        # Also check nested directories
        find src/ai_threat_monitor -type d -mindepth 2 | while read dir; do
          if [ ! -f "$dir/__init__.py" ]; then
            echo "Creating missing __init__.py in $dir"
            echo '"""Package module"""' > "$dir/__init__.py"
          fi
        done
        
        # Check nested directories too
        find src/ai_threat_monitor -type d -exec test -e '{}/__init__.py' \; -print || find src/ai_threat_monitor -type d ! -path "src/ai_threat_monitor/__pycache__*" -exec sh -c 'test -e "$1/__init__.py" || echo "Missing __init__.py in: $1"' _ {} \;
        
        echo "‚ö†Ô∏è  Development build with dev API endpoint (dev-api.securevector.io)"
    
    - name: Security scan before build
      run: |
        echo "üîç Scanning for potential secrets before publishing..."
        
        # Check for common secret patterns (excluding test files and documentation)
        if grep -r -i --exclude-dir=.git --exclude-dir=tests --exclude="*.md" \
           -E "(password|secret|private.*key)\s*[:=]\s*['\"][^'\"]{10,}" src/; then
          echo "‚ùå Potential secrets found in source code!"
          exit 1
        fi
        
        # Check for hardcoded production URLs (already handled above, but double-check)
        PROD_URLS=$(grep -r "api\.securevector\.io" src/ | grep -v "dev-api\.securevector\.io" || true)
        if [ -n "$PROD_URLS" ]; then
          echo "‚ùå Production API URLs still present:"
          echo "$PROD_URLS"
          echo ""
          echo "These should be replaced with dev-api.securevector.io for development builds"
          exit 1
        fi
        
        echo "‚úÖ Security scan passed"

    - name: Pre-build validation
      run: |
        echo "üîç Running pre-build import validation..."

        # Test that all critical imports work correctly
        PYTHONPATH=src python3 -c "
        try:
            from ai_threat_monitor import SecureVectorClient, AsyncSecureVectorClient
            from ai_threat_monitor.core.modes import APIMode, LocalMode, HybridMode
            from ai_threat_monitor.models import AnalysisResult, ThreatDetection
            from ai_threat_monitor.testing import MockSecureVectorClient, create_test_prompts
            print('‚úÖ All critical imports successful')
        except Exception as e:
            print(f'‚ùå Pre-build import test failed: {e}')
            import traceback
            traceback.print_exc()
            exit(1)
        "

        # Test basic functionality
        PYTHONPATH=src python3 -c "
        try:
            from ai_threat_monitor import SecureVectorClient
            client = SecureVectorClient()
            result = client.analyze('Hello world')
            assert hasattr(result, 'is_threat')
            print('‚úÖ Basic functionality works')
        except Exception as e:
            print(f'‚ùå Basic functionality test failed: {e}')
            import traceback
            traceback.print_exc()
            exit(1)
        "

        # Check for problematic relative imports that would break the package
        if grep -E "from \.\.(utils|models|core)" src/ai_threat_monitor/core/modes/api/api_mode.py 2>/dev/null; then
            echo "‚ùå Found problematic relative imports in api_mode.py"
            echo "These will cause 'ModuleNotFoundError: No module named ai_threat_monitor.core.modes.models'"
            exit 1
        fi

        echo "‚úÖ Pre-build validation passed"

    - name: Build package
      run: python -m build
    
    - name: Check package
      run: twine check dist/*
    
    - name: Publish to Test PyPI
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.TEST_PYPI_API_TOKEN }}
        TWINE_REPOSITORY_URL: https://test.pypi.org/legacy/
      run: |
        echo "Attempting to publish to Test PyPI..."
        echo "Package version: $DEV_VERSION"
        echo "Repository URL: $TWINE_REPOSITORY_URL"
        
        # Check if token is available
        if [ -z "$TWINE_PASSWORD" ]; then
          echo "‚ùå ERROR: TEST_PYPI_API_TOKEN secret is not set"
          exit 1
        fi
        
        # Upload with verbose output for debugging
        python -m twine upload --verbose dist/* || {
          echo "‚ùå Upload failed. Common causes:"
          echo "1. Package name 'securevector-ai-monitor' might already be taken"
          echo "2. Version $DEV_VERSION might already exist"
          echo "3. API token might be invalid or expired"
          echo "4. Token might not have upload permissions"
          exit 1
        }
    
    - name: Test install from Test PyPI
      run: |
        echo "Testing installation of development package..."
        echo "Package: securevector-ai-monitor-dev"
        echo "Version: $DEV_VERSION"

        # Install the package
        if pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ securevector-ai-monitor-dev; then
          echo "‚úÖ Package installation successful"
        else
          echo "‚ùå Package installation failed"
          exit 1
        fi

        # Test critical imports
        echo "Testing critical imports..."
        python -c "
        try:
            import ai_threat_monitor
            print('‚úÖ Main package import successful')

            from ai_threat_monitor import SecureVectorClient
            print('‚úÖ SecureVectorClient import successful')

            from ai_threat_monitor.models.analysis_result import AnalysisResult
            print('‚úÖ AnalysisResult import successful')

            # Test basic functionality
            client = SecureVectorClient()
            print('‚úÖ Client instantiation successful')
            print('‚úÖ All tests passed - package is working correctly!')

        except ImportError as e:
            print(f'‚ùå Import error: {e}')
            import traceback
            traceback.print_exc()
            exit(1)
        except Exception as e:
            print(f'‚ùå Error during testing: {e}')
            import traceback
            traceback.print_exc()
            exit(1)
        "
      continue-on-error: false

